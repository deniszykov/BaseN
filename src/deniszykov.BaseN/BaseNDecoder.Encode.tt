<#@ import namespace="System.Collections.Generic" #>
<#
	var outputSpanTypes = new[] { "byte", "char" };
	var inputOutputBufferTypes = new[] { new[] { "byte[]", "byte[]" }, new[] { "byte[]", "char[]" }, new[] { "byte*", "byte*" }, new[] { "byte*", "char*" } };
	var baseAlphabetSizes = new[] {16, 32, 64};
	var inputBlockSizes = new[] {1, 5, 3};
	var outputBlockSizes = new[] {2, 8, 4};
	var encodingBits = new[] {4, 5, 6};
	var pointerTypeReplacement = new Dictionary<string, string> {
		{ "byte*", "ByteSafePtr" },
		{ "char*", "CharSafePtr" },
	};

#>
//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All

using System;

namespace deniszykov.BaseN
{
	using CharSafePtr = UIntPtr;
	using ByteSafePtr = IntPtr;

    partial class BaseNDecoder
    {
<#
	for (var i = 0; i < baseAlphabetSizes.Length; i++)
	{
		var baseAlphabetSize = baseAlphabetSizes[i];
		var inputBlockSize = inputBlockSizes[i];
		var outputBlockSize = outputBlockSizes[i];
		var encodingBit = encodingBits[i];

		for (var t = 0; t < outputSpanTypes.Length; t++)
		{
#>
#if NETCOREAPP
		private void EncodeBase<#= baseAlphabetSize #>(ReadOnlySpan<byte> input, Span<<#= outputSpanTypes[t] #>> output, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (input.IsEmpty || output.IsEmpty)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = <#= inputBlockSize #>;
			const int OUTPUT_BLOCK_SIZE = <#= outputBlockSize #>;
			const int ENCODING_BITS = <#= encodingBit #>;
			const ulong ENCODING_MASK = <#= baseAlphabetSize - 1 #>;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(input.Length / INPUT_BLOCK_SIZE, output.Length / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
<#
	        for (int b = 0; b < inputBlockSize; b++)
            {
#>
					((ulong)input[<#= b #>] << (8 * <#= inputBlockSize - 1 - b #>)) <#= b != inputBlockSize - 1 ? "|" : ";" #>
<#
            }

#>

				// encode input
				var outputBlock =
<#
	        for (int b = 0; b < outputBlockSize; b++)
            {
#>
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * <#= b #>) & ENCODING_MASK)] << (8 * <#= b #>)) <#= b != outputBlockSize - 1 ? "|" : ";" #>
<#
            }

#>

				// flush output
<#
	        for (int b = 0; b < outputBlockSize; b++)
            {
#>
					output[<#= b #>] = (<#= outputSpanTypes[t] #>)((outputBlock >> (8 * <#= outputBlockSize - 1 - b #>)) & 255);
<#
            }
#>

				input = input.Slice(<#= inputBlockSize #>);
				output = output.Slice(<#= outputBlockSize #>);
			}

			// #3: encoding any final block (partial with padding)

			this.EncodeAny(input, output, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
<#
		}
#>

<#
		for (var t = 0; t < inputOutputBufferTypes.Length; t++)
		{
			var inputType = inputOutputBufferTypes[t][0];
			var outputType = inputOutputBufferTypes[t][1];
			var isPointerType = inputType.EndsWith("*");
			var outputElementType = outputType.Trim(new[] {'*', '[', ']'});
#>
#if !NETCOREAPP
		private <#= isPointerType ? "unsafe " : "" #>void EncodeBase<#= baseAlphabetSize #>(<#= inputType #> input, int inputOffset, int inputCount, <#= outputType #> output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = <#= inputBlockSize #>;
			const int OUTPUT_BLOCK_SIZE = <#= outputBlockSize #>;
			const int ENCODING_BITS = <#= encodingBit #>;
			const ulong ENCODING_MASK = <#= baseAlphabetSize - 1 #>;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
<#
	        for (int b = 0; b < inputBlockSize; b++)
            {
#>
					((ulong)input[inputOffset + <#= b #>] << (8 * <#= inputBlockSize - 1 - b #>)) <#= b != inputBlockSize - 1 ? "|" : ";" #>
<#
            }

#>

				// encode input
				var outputBlock =
<#
	        for (int b = 0; b < outputBlockSize; b++)
            {
#>
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * <#= b #>) & ENCODING_MASK)] << (8 * <#= b #>)) <#= b != outputBlockSize - 1 ? "|" : ";" #>
<#
            }

#>

				// flush output
<#
	        for (int b = 0; b < outputBlockSize; b++)
            {
#>
					output[outputOffset + <#= b #>] = (<#= outputElementType #>)((outputBlock >> (8 * <#= outputBlockSize - 1 - b #>)) & 255);
<#
            }
#>

				inputOffset += <#= inputBlockSize #>;
				outputOffset += <#= outputBlockSize #>;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;

<#
	        var inputSafeTypeCast = isPointerType ? "(" + pointerTypeReplacement[inputType] + ") ": "";
	        var outputSafeTypeCast = isPointerType ? "(" + pointerTypeReplacement[outputType] + ") " : "";
#>

			this.EncodeAny(<#= inputSafeTypeCast #>input, inputOffset, inputCount, <#= outputSafeTypeCast #>output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
<#
		}
	}

#>
    }
}
