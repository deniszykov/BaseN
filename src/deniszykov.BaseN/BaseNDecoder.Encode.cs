//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All

using System;

namespace deniszykov.BaseN
{
	using CharSafePtr = UIntPtr;
	using ByteSafePtr = IntPtr;

    partial class BaseNDecoder
    {
#if NETCOREAPP
		private unsafe void EncodeBase16(ReadOnlySpan<byte> input, Span<byte> output, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (input.IsEmpty || output.IsEmpty)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 1;
			const int OUTPUT_BLOCK_SIZE = 2;
			const int ENCODING_BITS = 4;
			const ulong ENCODING_MASK = 15;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			fixed (char* alphabetPtr = this.Alphabet.Alphabet)
			fixed (byte* outputBytes = &System.Runtime.InteropServices.MemoryMarshal.GetReference(output))
			fixed (byte* inputBytes = &System.Runtime.InteropServices.MemoryMarshal.GetReference(input))
			{
				var inputPtr = inputBytes;
				var outputPtr = outputBytes;

				// #2: encoding whole blocks

				var wholeBlocksToProcess = Math.Min(input.Length / INPUT_BLOCK_SIZE, output.Length / OUTPUT_BLOCK_SIZE);

				inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
				outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

				while (wholeBlocksToProcess-- > 0)
				{
					// fill input
					var inputBlock =
						((ulong)inputPtr[0] << (8 * 0)) ;

					// encode input
					outputPtr[1] = (byte)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
					outputPtr[0] = (byte)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);

					inputPtr += 1;
					outputPtr += 2;
				}

				input = input.Slice(inputUsed);
				output = output.Slice(outputUsed);
			}

			// #3: encoding any final block (partial with padding)

			this.EncodeAny(input, output, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if NETCOREAPP
		private unsafe void EncodeBase16(ReadOnlySpan<byte> input, Span<char> output, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (input.IsEmpty || output.IsEmpty)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 1;
			const int OUTPUT_BLOCK_SIZE = 2;
			const int ENCODING_BITS = 4;
			const ulong ENCODING_MASK = 15;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			fixed (char* alphabetPtr = this.Alphabet.Alphabet)
			fixed (char* outputBytes = &System.Runtime.InteropServices.MemoryMarshal.GetReference(output))
			fixed (byte* inputBytes = &System.Runtime.InteropServices.MemoryMarshal.GetReference(input))
			{
				var inputPtr = inputBytes;
				var outputPtr = outputBytes;

				// #2: encoding whole blocks

				var wholeBlocksToProcess = Math.Min(input.Length / INPUT_BLOCK_SIZE, output.Length / OUTPUT_BLOCK_SIZE);

				inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
				outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

				while (wholeBlocksToProcess-- > 0)
				{
					// fill input
					var inputBlock =
						((ulong)inputPtr[0] << (8 * 0)) ;

					// encode input
					outputPtr[1] = (char)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
					outputPtr[0] = (char)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);

					inputPtr += 1;
					outputPtr += 2;
				}

				input = input.Slice(inputUsed);
				output = output.Slice(outputUsed);
			}

			// #3: encoding any final block (partial with padding)

			this.EncodeAny(input, output, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif

#if !NETCOREAPP
		private void EncodeBase16(byte[] input, int inputOffset, int inputCount, byte[] output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 1;
			const int OUTPUT_BLOCK_SIZE = 2;
			const int ENCODING_BITS = 4;
			const ulong ENCODING_MASK = 15;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 0)) ;

				// encode input
				output[outputOffset + 1] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
				output[outputOffset + 0] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);

				inputOffset += 1;
				outputOffset += 2;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny(input, inputOffset, inputCount, output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private void EncodeBase16(byte[] input, int inputOffset, int inputCount, char[] output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 1;
			const int OUTPUT_BLOCK_SIZE = 2;
			const int ENCODING_BITS = 4;
			const ulong ENCODING_MASK = 15;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 0)) ;

				// encode input
				output[outputOffset + 1] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
				output[outputOffset + 0] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);

				inputOffset += 1;
				outputOffset += 2;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny(input, inputOffset, inputCount, output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private unsafe void EncodeBase16(byte* input, int inputOffset, int inputCount, byte* output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 1;
			const int OUTPUT_BLOCK_SIZE = 2;
			const int ENCODING_BITS = 4;
			const ulong ENCODING_MASK = 15;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 0)) ;

				// encode input
				output[outputOffset + 1] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
				output[outputOffset + 0] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);

				inputOffset += 1;
				outputOffset += 2;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny((ByteSafePtr) input, inputOffset, inputCount, (ByteSafePtr) output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private unsafe void EncodeBase16(byte* input, int inputOffset, int inputCount, char* output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 1;
			const int OUTPUT_BLOCK_SIZE = 2;
			const int ENCODING_BITS = 4;
			const ulong ENCODING_MASK = 15;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 0)) ;

				// encode input
				output[outputOffset + 1] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
				output[outputOffset + 0] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);

				inputOffset += 1;
				outputOffset += 2;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny((ByteSafePtr) input, inputOffset, inputCount, (CharSafePtr) output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if NETCOREAPP
		private unsafe void EncodeBase32(ReadOnlySpan<byte> input, Span<byte> output, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (input.IsEmpty || output.IsEmpty)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 5;
			const int OUTPUT_BLOCK_SIZE = 8;
			const int ENCODING_BITS = 5;
			const ulong ENCODING_MASK = 31;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			fixed (char* alphabetPtr = this.Alphabet.Alphabet)
			fixed (byte* outputBytes = &System.Runtime.InteropServices.MemoryMarshal.GetReference(output))
			fixed (byte* inputBytes = &System.Runtime.InteropServices.MemoryMarshal.GetReference(input))
			{
				var inputPtr = inputBytes;
				var outputPtr = outputBytes;

				// #2: encoding whole blocks

				var wholeBlocksToProcess = Math.Min(input.Length / INPUT_BLOCK_SIZE, output.Length / OUTPUT_BLOCK_SIZE);

				inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
				outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

				while (wholeBlocksToProcess-- > 0)
				{
					// fill input
					var inputBlock =
						((ulong)inputPtr[0] << (8 * 4)) |
						((ulong)inputPtr[1] << (8 * 3)) |
						((ulong)inputPtr[2] << (8 * 2)) |
						((ulong)inputPtr[3] << (8 * 1)) |
						((ulong)inputPtr[4] << (8 * 0)) ;

					// encode input
					outputPtr[7] = (byte)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
					outputPtr[6] = (byte)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);
					outputPtr[5] = (byte)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)]);
					outputPtr[4] = (byte)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)]);
					outputPtr[3] = (byte)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 4) & ENCODING_MASK)]);
					outputPtr[2] = (byte)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 5) & ENCODING_MASK)]);
					outputPtr[1] = (byte)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 6) & ENCODING_MASK)]);
					outputPtr[0] = (byte)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 7) & ENCODING_MASK)]);

					inputPtr += 5;
					outputPtr += 8;
				}

				input = input.Slice(inputUsed);
				output = output.Slice(outputUsed);
			}

			// #3: encoding any final block (partial with padding)

			this.EncodeAny(input, output, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if NETCOREAPP
		private unsafe void EncodeBase32(ReadOnlySpan<byte> input, Span<char> output, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (input.IsEmpty || output.IsEmpty)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 5;
			const int OUTPUT_BLOCK_SIZE = 8;
			const int ENCODING_BITS = 5;
			const ulong ENCODING_MASK = 31;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			fixed (char* alphabetPtr = this.Alphabet.Alphabet)
			fixed (char* outputBytes = &System.Runtime.InteropServices.MemoryMarshal.GetReference(output))
			fixed (byte* inputBytes = &System.Runtime.InteropServices.MemoryMarshal.GetReference(input))
			{
				var inputPtr = inputBytes;
				var outputPtr = outputBytes;

				// #2: encoding whole blocks

				var wholeBlocksToProcess = Math.Min(input.Length / INPUT_BLOCK_SIZE, output.Length / OUTPUT_BLOCK_SIZE);

				inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
				outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

				while (wholeBlocksToProcess-- > 0)
				{
					// fill input
					var inputBlock =
						((ulong)inputPtr[0] << (8 * 4)) |
						((ulong)inputPtr[1] << (8 * 3)) |
						((ulong)inputPtr[2] << (8 * 2)) |
						((ulong)inputPtr[3] << (8 * 1)) |
						((ulong)inputPtr[4] << (8 * 0)) ;

					// encode input
					outputPtr[7] = (char)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
					outputPtr[6] = (char)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);
					outputPtr[5] = (char)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)]);
					outputPtr[4] = (char)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)]);
					outputPtr[3] = (char)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 4) & ENCODING_MASK)]);
					outputPtr[2] = (char)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 5) & ENCODING_MASK)]);
					outputPtr[1] = (char)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 6) & ENCODING_MASK)]);
					outputPtr[0] = (char)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 7) & ENCODING_MASK)]);

					inputPtr += 5;
					outputPtr += 8;
				}

				input = input.Slice(inputUsed);
				output = output.Slice(outputUsed);
			}

			// #3: encoding any final block (partial with padding)

			this.EncodeAny(input, output, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif

#if !NETCOREAPP
		private void EncodeBase32(byte[] input, int inputOffset, int inputCount, byte[] output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 5;
			const int OUTPUT_BLOCK_SIZE = 8;
			const int ENCODING_BITS = 5;
			const ulong ENCODING_MASK = 31;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 4)) |
					((ulong)input[inputOffset + 1] << (8 * 3)) |
					((ulong)input[inputOffset + 2] << (8 * 2)) |
					((ulong)input[inputOffset + 3] << (8 * 1)) |
					((ulong)input[inputOffset + 4] << (8 * 0)) ;

				// encode input
				output[outputOffset + 7] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
				output[outputOffset + 6] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);
				output[outputOffset + 5] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)]);
				output[outputOffset + 4] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)]);
				output[outputOffset + 3] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 4) & ENCODING_MASK)]);
				output[outputOffset + 2] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 5) & ENCODING_MASK)]);
				output[outputOffset + 1] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 6) & ENCODING_MASK)]);
				output[outputOffset + 0] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 7) & ENCODING_MASK)]);

				inputOffset += 5;
				outputOffset += 8;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny(input, inputOffset, inputCount, output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private void EncodeBase32(byte[] input, int inputOffset, int inputCount, char[] output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 5;
			const int OUTPUT_BLOCK_SIZE = 8;
			const int ENCODING_BITS = 5;
			const ulong ENCODING_MASK = 31;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 4)) |
					((ulong)input[inputOffset + 1] << (8 * 3)) |
					((ulong)input[inputOffset + 2] << (8 * 2)) |
					((ulong)input[inputOffset + 3] << (8 * 1)) |
					((ulong)input[inputOffset + 4] << (8 * 0)) ;

				// encode input
				output[outputOffset + 7] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
				output[outputOffset + 6] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);
				output[outputOffset + 5] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)]);
				output[outputOffset + 4] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)]);
				output[outputOffset + 3] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 4) & ENCODING_MASK)]);
				output[outputOffset + 2] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 5) & ENCODING_MASK)]);
				output[outputOffset + 1] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 6) & ENCODING_MASK)]);
				output[outputOffset + 0] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 7) & ENCODING_MASK)]);

				inputOffset += 5;
				outputOffset += 8;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny(input, inputOffset, inputCount, output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private unsafe void EncodeBase32(byte* input, int inputOffset, int inputCount, byte* output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 5;
			const int OUTPUT_BLOCK_SIZE = 8;
			const int ENCODING_BITS = 5;
			const ulong ENCODING_MASK = 31;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 4)) |
					((ulong)input[inputOffset + 1] << (8 * 3)) |
					((ulong)input[inputOffset + 2] << (8 * 2)) |
					((ulong)input[inputOffset + 3] << (8 * 1)) |
					((ulong)input[inputOffset + 4] << (8 * 0)) ;

				// encode input
				output[outputOffset + 7] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
				output[outputOffset + 6] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);
				output[outputOffset + 5] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)]);
				output[outputOffset + 4] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)]);
				output[outputOffset + 3] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 4) & ENCODING_MASK)]);
				output[outputOffset + 2] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 5) & ENCODING_MASK)]);
				output[outputOffset + 1] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 6) & ENCODING_MASK)]);
				output[outputOffset + 0] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 7) & ENCODING_MASK)]);

				inputOffset += 5;
				outputOffset += 8;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny((ByteSafePtr) input, inputOffset, inputCount, (ByteSafePtr) output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private unsafe void EncodeBase32(byte* input, int inputOffset, int inputCount, char* output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 5;
			const int OUTPUT_BLOCK_SIZE = 8;
			const int ENCODING_BITS = 5;
			const ulong ENCODING_MASK = 31;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 4)) |
					((ulong)input[inputOffset + 1] << (8 * 3)) |
					((ulong)input[inputOffset + 2] << (8 * 2)) |
					((ulong)input[inputOffset + 3] << (8 * 1)) |
					((ulong)input[inputOffset + 4] << (8 * 0)) ;

				// encode input
				output[outputOffset + 7] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
				output[outputOffset + 6] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);
				output[outputOffset + 5] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)]);
				output[outputOffset + 4] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)]);
				output[outputOffset + 3] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 4) & ENCODING_MASK)]);
				output[outputOffset + 2] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 5) & ENCODING_MASK)]);
				output[outputOffset + 1] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 6) & ENCODING_MASK)]);
				output[outputOffset + 0] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 7) & ENCODING_MASK)]);

				inputOffset += 5;
				outputOffset += 8;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny((ByteSafePtr) input, inputOffset, inputCount, (CharSafePtr) output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if NETCOREAPP
		private unsafe void EncodeBase64(ReadOnlySpan<byte> input, Span<byte> output, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (input.IsEmpty || output.IsEmpty)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 3;
			const int OUTPUT_BLOCK_SIZE = 4;
			const int ENCODING_BITS = 6;
			const ulong ENCODING_MASK = 63;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			fixed (char* alphabetPtr = this.Alphabet.Alphabet)
			fixed (byte* outputBytes = &System.Runtime.InteropServices.MemoryMarshal.GetReference(output))
			fixed (byte* inputBytes = &System.Runtime.InteropServices.MemoryMarshal.GetReference(input))
			{
				var inputPtr = inputBytes;
				var outputPtr = outputBytes;

				// #2: encoding whole blocks

				var wholeBlocksToProcess = Math.Min(input.Length / INPUT_BLOCK_SIZE, output.Length / OUTPUT_BLOCK_SIZE);

				inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
				outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

				while (wholeBlocksToProcess-- > 0)
				{
					// fill input
					var inputBlock =
						((ulong)inputPtr[0] << (8 * 2)) |
						((ulong)inputPtr[1] << (8 * 1)) |
						((ulong)inputPtr[2] << (8 * 0)) ;

					// encode input
					outputPtr[3] = (byte)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
					outputPtr[2] = (byte)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);
					outputPtr[1] = (byte)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)]);
					outputPtr[0] = (byte)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)]);

					inputPtr += 3;
					outputPtr += 4;
				}

				input = input.Slice(inputUsed);
				output = output.Slice(outputUsed);
			}

			// #3: encoding any final block (partial with padding)

			this.EncodeAny(input, output, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if NETCOREAPP
		private unsafe void EncodeBase64(ReadOnlySpan<byte> input, Span<char> output, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (input.IsEmpty || output.IsEmpty)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 3;
			const int OUTPUT_BLOCK_SIZE = 4;
			const int ENCODING_BITS = 6;
			const ulong ENCODING_MASK = 63;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			fixed (char* alphabetPtr = this.Alphabet.Alphabet)
			fixed (char* outputBytes = &System.Runtime.InteropServices.MemoryMarshal.GetReference(output))
			fixed (byte* inputBytes = &System.Runtime.InteropServices.MemoryMarshal.GetReference(input))
			{
				var inputPtr = inputBytes;
				var outputPtr = outputBytes;

				// #2: encoding whole blocks

				var wholeBlocksToProcess = Math.Min(input.Length / INPUT_BLOCK_SIZE, output.Length / OUTPUT_BLOCK_SIZE);

				inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
				outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

				while (wholeBlocksToProcess-- > 0)
				{
					// fill input
					var inputBlock =
						((ulong)inputPtr[0] << (8 * 2)) |
						((ulong)inputPtr[1] << (8 * 1)) |
						((ulong)inputPtr[2] << (8 * 0)) ;

					// encode input
					outputPtr[3] = (char)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
					outputPtr[2] = (char)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);
					outputPtr[1] = (char)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)]);
					outputPtr[0] = (char)(alphabetPtr[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)]);

					inputPtr += 3;
					outputPtr += 4;
				}

				input = input.Slice(inputUsed);
				output = output.Slice(outputUsed);
			}

			// #3: encoding any final block (partial with padding)

			this.EncodeAny(input, output, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif

#if !NETCOREAPP
		private void EncodeBase64(byte[] input, int inputOffset, int inputCount, byte[] output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 3;
			const int OUTPUT_BLOCK_SIZE = 4;
			const int ENCODING_BITS = 6;
			const ulong ENCODING_MASK = 63;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 2)) |
					((ulong)input[inputOffset + 1] << (8 * 1)) |
					((ulong)input[inputOffset + 2] << (8 * 0)) ;

				// encode input
				output[outputOffset + 3] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
				output[outputOffset + 2] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);
				output[outputOffset + 1] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)]);
				output[outputOffset + 0] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)]);

				inputOffset += 3;
				outputOffset += 4;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny(input, inputOffset, inputCount, output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private void EncodeBase64(byte[] input, int inputOffset, int inputCount, char[] output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 3;
			const int OUTPUT_BLOCK_SIZE = 4;
			const int ENCODING_BITS = 6;
			const ulong ENCODING_MASK = 63;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 2)) |
					((ulong)input[inputOffset + 1] << (8 * 1)) |
					((ulong)input[inputOffset + 2] << (8 * 0)) ;

				// encode input
				output[outputOffset + 3] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
				output[outputOffset + 2] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);
				output[outputOffset + 1] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)]);
				output[outputOffset + 0] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)]);

				inputOffset += 3;
				outputOffset += 4;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny(input, inputOffset, inputCount, output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private unsafe void EncodeBase64(byte* input, int inputOffset, int inputCount, byte* output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 3;
			const int OUTPUT_BLOCK_SIZE = 4;
			const int ENCODING_BITS = 6;
			const ulong ENCODING_MASK = 63;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 2)) |
					((ulong)input[inputOffset + 1] << (8 * 1)) |
					((ulong)input[inputOffset + 2] << (8 * 0)) ;

				// encode input
				output[outputOffset + 3] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
				output[outputOffset + 2] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);
				output[outputOffset + 1] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)]);
				output[outputOffset + 0] = (byte)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)]);

				inputOffset += 3;
				outputOffset += 4;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny((ByteSafePtr) input, inputOffset, inputCount, (ByteSafePtr) output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private unsafe void EncodeBase64(byte* input, int inputOffset, int inputCount, char* output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 3;
			const int OUTPUT_BLOCK_SIZE = 4;
			const int ENCODING_BITS = 6;
			const ulong ENCODING_MASK = 63;

			var alphabetChars = this.Alphabet.Alphabet ?? throw new InvalidOperationException();

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 2)) |
					((ulong)input[inputOffset + 1] << (8 * 1)) |
					((ulong)input[inputOffset + 2] << (8 * 0)) ;

				// encode input
				output[outputOffset + 3] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)]);
				output[outputOffset + 2] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)]);
				output[outputOffset + 1] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)]);
				output[outputOffset + 0] = (char)(alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)]);

				inputOffset += 3;
				outputOffset += 4;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny((ByteSafePtr) input, inputOffset, inputCount, (CharSafePtr) output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
    }
}
