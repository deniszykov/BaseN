//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All

using System;

namespace deniszykov.BaseN
{
	using CharSafePtr = UIntPtr;
	using ByteSafePtr = IntPtr;

    partial class BaseNDecoder
    {
#if NETCOREAPP
		private void EncodeBase16(ReadOnlySpan<byte> input, Span<byte> output, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (input.IsEmpty || output.IsEmpty)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 1;
			const int OUTPUT_BLOCK_SIZE = 2;
			const int ENCODING_BITS = 4;
			const ulong ENCODING_MASK = 15;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(input.Length / INPUT_BLOCK_SIZE, output.Length / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[0] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) ;

				// flush output
					output[0] = (byte)((outputBlock >> (8 * 1)) & 255);
					output[1] = (byte)((outputBlock >> (8 * 0)) & 255);

				input = input.Slice(1);
				output = output.Slice(2);
			}

			// #3: encoding any final block (partial with padding)

			this.EncodeAny(input, output, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if NETCOREAPP
		private void EncodeBase16(ReadOnlySpan<byte> input, Span<char> output, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (input.IsEmpty || output.IsEmpty)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 1;
			const int OUTPUT_BLOCK_SIZE = 2;
			const int ENCODING_BITS = 4;
			const ulong ENCODING_MASK = 15;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(input.Length / INPUT_BLOCK_SIZE, output.Length / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[0] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) ;

				// flush output
					output[0] = (char)((outputBlock >> (8 * 1)) & 255);
					output[1] = (char)((outputBlock >> (8 * 0)) & 255);

				input = input.Slice(1);
				output = output.Slice(2);
			}

			// #3: encoding any final block (partial with padding)

			this.EncodeAny(input, output, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif

#if !NETCOREAPP
		private void EncodeBase16(byte[] input, int inputOffset, int inputCount, byte[] output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 1;
			const int OUTPUT_BLOCK_SIZE = 2;
			const int ENCODING_BITS = 4;
			const ulong ENCODING_MASK = 15;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) ;

				// flush output
					output[outputOffset + 0] = (byte)((outputBlock >> (8 * 1)) & 255);
					output[outputOffset + 1] = (byte)((outputBlock >> (8 * 0)) & 255);

				inputOffset += 1;
				outputOffset += 2;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny(input, inputOffset, inputCount, output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private void EncodeBase16(byte[] input, int inputOffset, int inputCount, char[] output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 1;
			const int OUTPUT_BLOCK_SIZE = 2;
			const int ENCODING_BITS = 4;
			const ulong ENCODING_MASK = 15;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) ;

				// flush output
					output[outputOffset + 0] = (char)((outputBlock >> (8 * 1)) & 255);
					output[outputOffset + 1] = (char)((outputBlock >> (8 * 0)) & 255);

				inputOffset += 1;
				outputOffset += 2;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny(input, inputOffset, inputCount, output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private unsafe void EncodeBase16(byte* input, int inputOffset, int inputCount, byte* output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 1;
			const int OUTPUT_BLOCK_SIZE = 2;
			const int ENCODING_BITS = 4;
			const ulong ENCODING_MASK = 15;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) ;

				// flush output
					output[outputOffset + 0] = (byte)((outputBlock >> (8 * 1)) & 255);
					output[outputOffset + 1] = (byte)((outputBlock >> (8 * 0)) & 255);

				inputOffset += 1;
				outputOffset += 2;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny((ByteSafePtr) input, inputOffset, inputCount, (ByteSafePtr) output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private unsafe void EncodeBase16(byte* input, int inputOffset, int inputCount, char* output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 1;
			const int OUTPUT_BLOCK_SIZE = 2;
			const int ENCODING_BITS = 4;
			const ulong ENCODING_MASK = 15;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) ;

				// flush output
					output[outputOffset + 0] = (char)((outputBlock >> (8 * 1)) & 255);
					output[outputOffset + 1] = (char)((outputBlock >> (8 * 0)) & 255);

				inputOffset += 1;
				outputOffset += 2;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny((ByteSafePtr) input, inputOffset, inputCount, (CharSafePtr) output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if NETCOREAPP
		private void EncodeBase32(ReadOnlySpan<byte> input, Span<byte> output, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (input.IsEmpty || output.IsEmpty)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 5;
			const int OUTPUT_BLOCK_SIZE = 8;
			const int ENCODING_BITS = 5;
			const ulong ENCODING_MASK = 31;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(input.Length / INPUT_BLOCK_SIZE, output.Length / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[0] << (8 * 4)) |
					((ulong)input[1] << (8 * 3)) |
					((ulong)input[2] << (8 * 2)) |
					((ulong)input[3] << (8 * 1)) |
					((ulong)input[4] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)] << (8 * 2)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)] << (8 * 3)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 4) & ENCODING_MASK)] << (8 * 4)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 5) & ENCODING_MASK)] << (8 * 5)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 6) & ENCODING_MASK)] << (8 * 6)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 7) & ENCODING_MASK)] << (8 * 7)) ;

				// flush output
					output[0] = (byte)((outputBlock >> (8 * 7)) & 255);
					output[1] = (byte)((outputBlock >> (8 * 6)) & 255);
					output[2] = (byte)((outputBlock >> (8 * 5)) & 255);
					output[3] = (byte)((outputBlock >> (8 * 4)) & 255);
					output[4] = (byte)((outputBlock >> (8 * 3)) & 255);
					output[5] = (byte)((outputBlock >> (8 * 2)) & 255);
					output[6] = (byte)((outputBlock >> (8 * 1)) & 255);
					output[7] = (byte)((outputBlock >> (8 * 0)) & 255);

				input = input.Slice(5);
				output = output.Slice(8);
			}

			// #3: encoding any final block (partial with padding)

			this.EncodeAny(input, output, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if NETCOREAPP
		private void EncodeBase32(ReadOnlySpan<byte> input, Span<char> output, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (input.IsEmpty || output.IsEmpty)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 5;
			const int OUTPUT_BLOCK_SIZE = 8;
			const int ENCODING_BITS = 5;
			const ulong ENCODING_MASK = 31;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(input.Length / INPUT_BLOCK_SIZE, output.Length / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[0] << (8 * 4)) |
					((ulong)input[1] << (8 * 3)) |
					((ulong)input[2] << (8 * 2)) |
					((ulong)input[3] << (8 * 1)) |
					((ulong)input[4] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)] << (8 * 2)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)] << (8 * 3)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 4) & ENCODING_MASK)] << (8 * 4)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 5) & ENCODING_MASK)] << (8 * 5)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 6) & ENCODING_MASK)] << (8 * 6)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 7) & ENCODING_MASK)] << (8 * 7)) ;

				// flush output
					output[0] = (char)((outputBlock >> (8 * 7)) & 255);
					output[1] = (char)((outputBlock >> (8 * 6)) & 255);
					output[2] = (char)((outputBlock >> (8 * 5)) & 255);
					output[3] = (char)((outputBlock >> (8 * 4)) & 255);
					output[4] = (char)((outputBlock >> (8 * 3)) & 255);
					output[5] = (char)((outputBlock >> (8 * 2)) & 255);
					output[6] = (char)((outputBlock >> (8 * 1)) & 255);
					output[7] = (char)((outputBlock >> (8 * 0)) & 255);

				input = input.Slice(5);
				output = output.Slice(8);
			}

			// #3: encoding any final block (partial with padding)

			this.EncodeAny(input, output, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif

#if !NETCOREAPP
		private void EncodeBase32(byte[] input, int inputOffset, int inputCount, byte[] output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 5;
			const int OUTPUT_BLOCK_SIZE = 8;
			const int ENCODING_BITS = 5;
			const ulong ENCODING_MASK = 31;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 4)) |
					((ulong)input[inputOffset + 1] << (8 * 3)) |
					((ulong)input[inputOffset + 2] << (8 * 2)) |
					((ulong)input[inputOffset + 3] << (8 * 1)) |
					((ulong)input[inputOffset + 4] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)] << (8 * 2)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)] << (8 * 3)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 4) & ENCODING_MASK)] << (8 * 4)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 5) & ENCODING_MASK)] << (8 * 5)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 6) & ENCODING_MASK)] << (8 * 6)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 7) & ENCODING_MASK)] << (8 * 7)) ;

				// flush output
					output[outputOffset + 0] = (byte)((outputBlock >> (8 * 7)) & 255);
					output[outputOffset + 1] = (byte)((outputBlock >> (8 * 6)) & 255);
					output[outputOffset + 2] = (byte)((outputBlock >> (8 * 5)) & 255);
					output[outputOffset + 3] = (byte)((outputBlock >> (8 * 4)) & 255);
					output[outputOffset + 4] = (byte)((outputBlock >> (8 * 3)) & 255);
					output[outputOffset + 5] = (byte)((outputBlock >> (8 * 2)) & 255);
					output[outputOffset + 6] = (byte)((outputBlock >> (8 * 1)) & 255);
					output[outputOffset + 7] = (byte)((outputBlock >> (8 * 0)) & 255);

				inputOffset += 5;
				outputOffset += 8;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny(input, inputOffset, inputCount, output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private void EncodeBase32(byte[] input, int inputOffset, int inputCount, char[] output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 5;
			const int OUTPUT_BLOCK_SIZE = 8;
			const int ENCODING_BITS = 5;
			const ulong ENCODING_MASK = 31;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 4)) |
					((ulong)input[inputOffset + 1] << (8 * 3)) |
					((ulong)input[inputOffset + 2] << (8 * 2)) |
					((ulong)input[inputOffset + 3] << (8 * 1)) |
					((ulong)input[inputOffset + 4] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)] << (8 * 2)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)] << (8 * 3)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 4) & ENCODING_MASK)] << (8 * 4)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 5) & ENCODING_MASK)] << (8 * 5)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 6) & ENCODING_MASK)] << (8 * 6)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 7) & ENCODING_MASK)] << (8 * 7)) ;

				// flush output
					output[outputOffset + 0] = (char)((outputBlock >> (8 * 7)) & 255);
					output[outputOffset + 1] = (char)((outputBlock >> (8 * 6)) & 255);
					output[outputOffset + 2] = (char)((outputBlock >> (8 * 5)) & 255);
					output[outputOffset + 3] = (char)((outputBlock >> (8 * 4)) & 255);
					output[outputOffset + 4] = (char)((outputBlock >> (8 * 3)) & 255);
					output[outputOffset + 5] = (char)((outputBlock >> (8 * 2)) & 255);
					output[outputOffset + 6] = (char)((outputBlock >> (8 * 1)) & 255);
					output[outputOffset + 7] = (char)((outputBlock >> (8 * 0)) & 255);

				inputOffset += 5;
				outputOffset += 8;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny(input, inputOffset, inputCount, output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private unsafe void EncodeBase32(byte* input, int inputOffset, int inputCount, byte* output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 5;
			const int OUTPUT_BLOCK_SIZE = 8;
			const int ENCODING_BITS = 5;
			const ulong ENCODING_MASK = 31;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 4)) |
					((ulong)input[inputOffset + 1] << (8 * 3)) |
					((ulong)input[inputOffset + 2] << (8 * 2)) |
					((ulong)input[inputOffset + 3] << (8 * 1)) |
					((ulong)input[inputOffset + 4] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)] << (8 * 2)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)] << (8 * 3)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 4) & ENCODING_MASK)] << (8 * 4)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 5) & ENCODING_MASK)] << (8 * 5)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 6) & ENCODING_MASK)] << (8 * 6)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 7) & ENCODING_MASK)] << (8 * 7)) ;

				// flush output
					output[outputOffset + 0] = (byte)((outputBlock >> (8 * 7)) & 255);
					output[outputOffset + 1] = (byte)((outputBlock >> (8 * 6)) & 255);
					output[outputOffset + 2] = (byte)((outputBlock >> (8 * 5)) & 255);
					output[outputOffset + 3] = (byte)((outputBlock >> (8 * 4)) & 255);
					output[outputOffset + 4] = (byte)((outputBlock >> (8 * 3)) & 255);
					output[outputOffset + 5] = (byte)((outputBlock >> (8 * 2)) & 255);
					output[outputOffset + 6] = (byte)((outputBlock >> (8 * 1)) & 255);
					output[outputOffset + 7] = (byte)((outputBlock >> (8 * 0)) & 255);

				inputOffset += 5;
				outputOffset += 8;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny((ByteSafePtr) input, inputOffset, inputCount, (ByteSafePtr) output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private unsafe void EncodeBase32(byte* input, int inputOffset, int inputCount, char* output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 5;
			const int OUTPUT_BLOCK_SIZE = 8;
			const int ENCODING_BITS = 5;
			const ulong ENCODING_MASK = 31;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 4)) |
					((ulong)input[inputOffset + 1] << (8 * 3)) |
					((ulong)input[inputOffset + 2] << (8 * 2)) |
					((ulong)input[inputOffset + 3] << (8 * 1)) |
					((ulong)input[inputOffset + 4] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)] << (8 * 2)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)] << (8 * 3)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 4) & ENCODING_MASK)] << (8 * 4)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 5) & ENCODING_MASK)] << (8 * 5)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 6) & ENCODING_MASK)] << (8 * 6)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 7) & ENCODING_MASK)] << (8 * 7)) ;

				// flush output
					output[outputOffset + 0] = (char)((outputBlock >> (8 * 7)) & 255);
					output[outputOffset + 1] = (char)((outputBlock >> (8 * 6)) & 255);
					output[outputOffset + 2] = (char)((outputBlock >> (8 * 5)) & 255);
					output[outputOffset + 3] = (char)((outputBlock >> (8 * 4)) & 255);
					output[outputOffset + 4] = (char)((outputBlock >> (8 * 3)) & 255);
					output[outputOffset + 5] = (char)((outputBlock >> (8 * 2)) & 255);
					output[outputOffset + 6] = (char)((outputBlock >> (8 * 1)) & 255);
					output[outputOffset + 7] = (char)((outputBlock >> (8 * 0)) & 255);

				inputOffset += 5;
				outputOffset += 8;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny((ByteSafePtr) input, inputOffset, inputCount, (CharSafePtr) output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if NETCOREAPP
		private void EncodeBase64(ReadOnlySpan<byte> input, Span<byte> output, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (input.IsEmpty || output.IsEmpty)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 3;
			const int OUTPUT_BLOCK_SIZE = 4;
			const int ENCODING_BITS = 6;
			const ulong ENCODING_MASK = 63;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(input.Length / INPUT_BLOCK_SIZE, output.Length / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[0] << (8 * 2)) |
					((ulong)input[1] << (8 * 1)) |
					((ulong)input[2] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)] << (8 * 2)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)] << (8 * 3)) ;

				// flush output
					output[0] = (byte)((outputBlock >> (8 * 3)) & 255);
					output[1] = (byte)((outputBlock >> (8 * 2)) & 255);
					output[2] = (byte)((outputBlock >> (8 * 1)) & 255);
					output[3] = (byte)((outputBlock >> (8 * 0)) & 255);

				input = input.Slice(3);
				output = output.Slice(4);
			}

			// #3: encoding any final block (partial with padding)

			this.EncodeAny(input, output, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if NETCOREAPP
		private void EncodeBase64(ReadOnlySpan<byte> input, Span<char> output, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (input.IsEmpty || output.IsEmpty)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 3;
			const int OUTPUT_BLOCK_SIZE = 4;
			const int ENCODING_BITS = 6;
			const ulong ENCODING_MASK = 63;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(input.Length / INPUT_BLOCK_SIZE, output.Length / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[0] << (8 * 2)) |
					((ulong)input[1] << (8 * 1)) |
					((ulong)input[2] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)] << (8 * 2)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)] << (8 * 3)) ;

				// flush output
					output[0] = (char)((outputBlock >> (8 * 3)) & 255);
					output[1] = (char)((outputBlock >> (8 * 2)) & 255);
					output[2] = (char)((outputBlock >> (8 * 1)) & 255);
					output[3] = (char)((outputBlock >> (8 * 0)) & 255);

				input = input.Slice(3);
				output = output.Slice(4);
			}

			// #3: encoding any final block (partial with padding)

			this.EncodeAny(input, output, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif

#if !NETCOREAPP
		private void EncodeBase64(byte[] input, int inputOffset, int inputCount, byte[] output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 3;
			const int OUTPUT_BLOCK_SIZE = 4;
			const int ENCODING_BITS = 6;
			const ulong ENCODING_MASK = 63;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 2)) |
					((ulong)input[inputOffset + 1] << (8 * 1)) |
					((ulong)input[inputOffset + 2] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)] << (8 * 2)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)] << (8 * 3)) ;

				// flush output
					output[outputOffset + 0] = (byte)((outputBlock >> (8 * 3)) & 255);
					output[outputOffset + 1] = (byte)((outputBlock >> (8 * 2)) & 255);
					output[outputOffset + 2] = (byte)((outputBlock >> (8 * 1)) & 255);
					output[outputOffset + 3] = (byte)((outputBlock >> (8 * 0)) & 255);

				inputOffset += 3;
				outputOffset += 4;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny(input, inputOffset, inputCount, output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private void EncodeBase64(byte[] input, int inputOffset, int inputCount, char[] output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 3;
			const int OUTPUT_BLOCK_SIZE = 4;
			const int ENCODING_BITS = 6;
			const ulong ENCODING_MASK = 63;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 2)) |
					((ulong)input[inputOffset + 1] << (8 * 1)) |
					((ulong)input[inputOffset + 2] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)] << (8 * 2)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)] << (8 * 3)) ;

				// flush output
					output[outputOffset + 0] = (char)((outputBlock >> (8 * 3)) & 255);
					output[outputOffset + 1] = (char)((outputBlock >> (8 * 2)) & 255);
					output[outputOffset + 2] = (char)((outputBlock >> (8 * 1)) & 255);
					output[outputOffset + 3] = (char)((outputBlock >> (8 * 0)) & 255);

				inputOffset += 3;
				outputOffset += 4;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny(input, inputOffset, inputCount, output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private unsafe void EncodeBase64(byte* input, int inputOffset, int inputCount, byte* output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 3;
			const int OUTPUT_BLOCK_SIZE = 4;
			const int ENCODING_BITS = 6;
			const ulong ENCODING_MASK = 63;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 2)) |
					((ulong)input[inputOffset + 1] << (8 * 1)) |
					((ulong)input[inputOffset + 2] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)] << (8 * 2)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)] << (8 * 3)) ;

				// flush output
					output[outputOffset + 0] = (byte)((outputBlock >> (8 * 3)) & 255);
					output[outputOffset + 1] = (byte)((outputBlock >> (8 * 2)) & 255);
					output[outputOffset + 2] = (byte)((outputBlock >> (8 * 1)) & 255);
					output[outputOffset + 3] = (byte)((outputBlock >> (8 * 0)) & 255);

				inputOffset += 3;
				outputOffset += 4;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny((ByteSafePtr) input, inputOffset, inputCount, (ByteSafePtr) output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
#if !NETCOREAPP
		private unsafe void EncodeBase64(byte* input, int inputOffset, int inputCount, char* output, int outputOffset, int outputCount, bool flush, out int inputUsed, out int outputUsed, out bool completed)
		{
			if (inputCount == 0 || outputCount == 0)
			{
				inputUsed = outputUsed = 0;
				completed = true;
				return;
			}

			// #1: preparing
			const int INPUT_BLOCK_SIZE = 3;
			const int OUTPUT_BLOCK_SIZE = 4;
			const int ENCODING_BITS = 6;
			const ulong ENCODING_MASK = 63;

			var alphabetChars = this.Alphabet.Alphabet;

			// #2: encoding whole blocks

			var wholeBlocksToProcess = Math.Min(inputCount / INPUT_BLOCK_SIZE, outputCount / OUTPUT_BLOCK_SIZE);

			inputUsed = INPUT_BLOCK_SIZE * wholeBlocksToProcess;
			outputUsed = OUTPUT_BLOCK_SIZE * wholeBlocksToProcess;

			while (wholeBlocksToProcess-- > 0)
			{
				// fill input
				var inputBlock =
					((ulong)input[inputOffset + 0] << (8 * 2)) |
					((ulong)input[inputOffset + 1] << (8 * 1)) |
					((ulong)input[inputOffset + 2] << (8 * 0)) ;

				// encode input
				var outputBlock =
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 0) & ENCODING_MASK)] << (8 * 0)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 1) & ENCODING_MASK)] << (8 * 1)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 2) & ENCODING_MASK)] << (8 * 2)) |
					((ulong)alphabetChars[(int)((inputBlock >> ENCODING_BITS * 3) & ENCODING_MASK)] << (8 * 3)) ;

				// flush output
					output[outputOffset + 0] = (char)((outputBlock >> (8 * 3)) & 255);
					output[outputOffset + 1] = (char)((outputBlock >> (8 * 2)) & 255);
					output[outputOffset + 2] = (char)((outputBlock >> (8 * 1)) & 255);
					output[outputOffset + 3] = (char)((outputBlock >> (8 * 0)) & 255);

				inputOffset += 3;
				outputOffset += 4;
			}

			// #3: encoding any final block (partial with padding)

			inputCount -= inputUsed;
			outputCount -= outputUsed;


			this.EncodeAny((ByteSafePtr) input, inputOffset, inputCount, (CharSafePtr) output, outputOffset, outputCount, flush, out var finalInputUsed, out var finalOutputUsed, out completed);

			inputUsed += finalInputUsed;
			outputUsed += finalOutputUsed;
		}
#endif
    }
}
